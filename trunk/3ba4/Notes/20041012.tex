% $Id$

\documentclass[a4paper,12pt]{article}
\usepackage{amssymb}

\setlength{\parindent}{0mm}
\setlength{\parskip}{7.5mm}

\begin{document}

\title{Course 3BA4: Computer Architecture II \\ Lecture Notes \\ $12^{th}$ October 2004}

\maketitle

Joy's Law:

$MIPS = 2^{year - 1984}$

$MIPS$ - Millions of instructions per second by a single microprocessor.


More realistic rate is a doubling of the $MIPS$ every 18 months.


How do we jeep up with this tradition?

How to improve:

\begin{itemize}

\item Increased Clock Rate

\item Reduced Vs Complex Instruction Set (RISC Vs CISC)

\item Burst Memory Access

\item Integrated Onboard Memory Management Units/Floating Point Units

\item Pipelining and Super Pipelining

\item Super Sealor (multiple instructions per clock cycle)

\item Speculative execution

\item Multi-level chip instruction \& data caches.

\item Multi Processor Support

\item Multi Media Instruction Sets (eg Intel Pentium MMX)

\end{itemize}

\section*{RISC Vs CISC}

For a given benchmark, the performance $P$ (time to compute) of a
particular computer:

\[ P = \frac{1}{I * C * \frac{1}{S}} \]

Where

$I$ is the instruction count executed in benchmarks \\
$C$ is the clock cycles per instruction \\
$S$ is the clock speed

- RISC approach attempts to reduce $C$

- CISC approach attempts to reduce $I$


Measuring identical clock speeds:

\[ C_{RISC} < C_{CSIC} \]

(Both $> 1$ with Super Scalar Design)

- RISC execute more instructions per benchmark than their CISC
  counterparts ($\approx 10 - 30\%$).

- RISC designers clain that their approach has a side effect of
  increasing $S$  

\section*{RISC-I Design Criteria}

For effective single chip solution artificially placed the following
design constraints.

\begin{itemize}
\item Execute one instruction per cycle (compared to at least $8$ for
the $S$).

\subitem Instructions have to be simple to be executed in one cycle

\subitem microprogramming not neccessary, can be implemented as a simple
state machine

\item Make all instructions the same size

\subitem Simplifies implementation

\item Access main memory with load and store instructions. (ie add
cannot access memory)

\subitem Only one addressing mode (indexed)

\item Limited support for high level languages (meaning C anf hence
UNIX)

\subitem proceedure calling

\subitem local variables

\subitem constants
\end{itemize}

\section*{RISC-I Arithmetic Instructions}

12 arithmetic instructions of the form

\[ R_{dst} = R_{src1} op S_{2} \]

($3$ address instructions)

Where

$S_{2}$ is a register or an immediate constant

Op:

add, add with carry, subtract, subtract with carry/borrow, reverse
subtract, reverse subtract with carry/borrow

\begin{tabular}{l l l}
68000 			&	RISC-I 				&	Comment	\\
move.l rm,rn	&	add r0,rm,rm 		&	\\
cmp.l rm,rn		&	sub rm,rn,r0 {C}	& {C} - Set Condition codes	\\
tst.l rn			&	sub rn,r0,r0 {C}	&	\\
clr.l rn			&	add r0,r0,rn		&	\\
neg.l rm,rn		&	sub r0,rm,rn		& 2s Complement \\
com.l rm,rn		&	xor rm,\#-1,rn		& 1s Complement \\
incl.l rn		&	add rn,\#1,rn		&	\\
\end{tabular}

\end{document}
