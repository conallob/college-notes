<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft FrontPage 5.0">
<TITLE>Trinity_3rd-Term_03-04</TITLE>
<META NAME="Version" CONTENT="8.0.3410">
<META NAME="Date" CONTENT="10/11/96">
<META NAME="Template" CONTENT="C:\PROGRAM FILES\MICROSOFT OFFICE\OFFICE\html.dot">
<style>
<!--
 div.MsoNormal
	{mso-style-parent:"";
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:"Times New Roman";
	margin-left:0cm; margin-right:0cm; margin-top:0cm}
 li.MsoNormal
	{mso-style-parent:"";
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:"Times New Roman";
	margin-left:0cm; margin-right:0cm; margin-top:0cm}
-->
</style>
</HEAD>
<BODY TEXT="#000000" LINK="#0000FF" VLINK="#800080" BGCOLOR="#FFFFCC">

<FONT FACE="Arial" SIZE=5>

<B><P ALIGN="CENTER">2BA2 -- Programming Techniques</P>
<P ALIGN="CENTER">Trinity Term -- 3<SUP>rd</SUP> Term<BR>
2003 - 04</P>
</B></FONT><P ALIGN="CENTER">Dr. Hugh Gibbons</P>
<P ALIGN="CENTER">Email: <A HREF="mailto:hugh.gibbons@cs.tcd.ie">hugh.gibbons@cs.tcd.ie</A></P>
<H3><A NAME="contents">Timetable: Trinity (3<SUP>rd</SUP>) Term</H3>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=612>
<TR><TD WIDTH="110" VALIGN="TOP">
<B><P>Monday</B></TD>
<TD WIDTH="113" VALIGN="TOP">
<B><P>Tuesday</B></TD>
<TD WIDTH="101" VALIGN="TOP">
<B><P>Wednesday</B></TD>
<TD WIDTH="87" VALIGN="TOP">
<B><P>Thursday.</B></TD>
<TD WIDTH="113" VALIGN="TOP">
<B><P>Friday</B></TD>
</TR>
<TR><TD WIDTH="110" VALIGN="TOP">
<P>3pm: Ham 5</TD>
<TD WIDTH="113" VALIGN="TOP">
<P>2pm: Mus 20</P>
  </TD>
<TD WIDTH="101" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="87" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="113" VALIGN="TOP">
<P>10am: Ham 5</TD>
</TR>
</TABLE>
</CENTER></P>

<P ALIGN="CENTER">&nbsp;</P>
<FONT FACE="Arial" SIZE=4><I>
<B><P ALIGN="CENTER">Contents</B></I></FONT></A> [<A HREF="index.html"><FONT SIZE=4>Back to Main Index</FONT></A>]</P>
<P ALIGN="CENTER"><CENTER><TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=740>
<TR><TD WIDTH="8%" VALIGN="TOP">
<FONT FACE="Book Antiqua" SIZE=2><P ALIGN="CENTER">Lecture</FONT></TD>
<TD WIDTH="61%" VALIGN="TOP">
<FONT FACE="Book Antiqua"><P ALIGN="CENTER">Trinity (3<SUP>rd</SUP>) Term</FONT></TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<tr>
  <td width="8%" valign=top style='width:8.0%;padding:5.25pt 5.25pt 5.25pt 5.25pt'>
  <p align=center style='text-align:center'>1</p>
  </td>
  <td width="61%" valign=top style='width:61.0%;padding:5.25pt 5.25pt 5.25pt 5.25pt'>
  <p>
  <a style="color: blue; text-decoration: underline; text-underline: single" href="24_graphs/graphs.pdf">Undirected Graphs
  </a> </p>
  </td>
  <td width="31%" valign=top style='width:31.0%;padding:5.25pt 5.25pt 5.25pt 5.25pt'>
  <p>
  <a style="color: blue; text-decoration: underline; text-underline: single" href="#graphs">Summary</a> </p>
  </td>
 </tr>
<tr>
  <td width="8%" valign=top style='width:8.0%;padding:5.25pt 5.25pt 5.25pt 5.25pt'>
  <p align=center style='text-align:center'>2</p>
  </td>
  <td width="61%" valign=top style='width:61.0%;padding:5.25pt 5.25pt 5.25pt 5.25pt'>
  <p>
  <a style="color: blue; text-decoration: underline; text-underline: single" href="25_dag_topological-sort/dag_topol-sort.pdf">Directed Acyclic
  Graph</a> (DAG)&nbsp;</p>
  </td>
  <td width="31%" valign=top style='width:31.0%;padding:5.25pt 5.25pt 5.25pt 5.25pt'>
  <p>
  <a style="color: blue; text-decoration: underline; text-underline: single" href="#dag">Summary &nbsp;</a></p>
  </td>
 </tr>
<tr>
  <td width="8%" valign=top style='width:8.0%;padding:5.25pt 5.25pt 5.25pt 5.25pt'>
  <p align=center style='text-align:center'>3</p>
  </td>
  <td width="61%" valign=top style='width:61.0%;padding:5.25pt 5.25pt 5.25pt 5.25pt'>
  <p>
  <a style="color: blue; text-decoration: underline; text-underline: single" href="26_Hamilton/hamilton.pdf">Hamilton Circuit</a> </p>
  </td>
  <td width="31%" valign=top style='width:31.0%;padding:5.25pt 5.25pt 5.25pt 5.25pt'>
  <p>
  <a style="color: blue; text-decoration: underline; text-underline: single" href="#hamilton">Summary
  </a> </p>
  </td>
 </tr>
<tr>
  <TD WIDTH="8%" VALIGN="TOP">
<P ALIGN="CENTER">4</TD>
<TD WIDTH="61%" VALIGN="TOP">
<P><a href="27_nr-inorder/nr-inorder.pdf">Non-Recursive Inorder</a> (Stacks &amp; Threaded Tree)</TD>
<TD WIDTH="31%" VALIGN="TOP">
<P><A HREF="#non_rec_inord">Summary </A></TD>
</tr>
<tr>
  <TD WIDTH="8%" VALIGN="TOP">
<P ALIGN="CENTER">5</TD>
<TD WIDTH="61%" VALIGN="TOP">
<P><a href="28_morris/morris.pdf">Morris Inorder</a> &nbsp;&nbsp;&nbsp; </TD>
<TD WIDTH="31%" VALIGN="TOP">
<P><A HREF="#morris">Summary</A> &nbsp;</TD>
</tr>
<tr>
  <TD WIDTH="8%" VALIGN="TOP">
<P ALIGN="CENTER">6</TD>
<TD WIDTH="61%" VALIGN="TOP">
<P><a href="29_balanced_tree/balanced_tree.pdf">Balanced Trees</a>&nbsp; &nbsp;(Perfectly  Balanced .v. Height Balanced)</TD>
<TD WIDTH="31%" VALIGN="TOP">
<P><A HREF="#balanced_trees">Summary</A> &nbsp;</TD>
</tr>
<tr>
  <TD WIDTH="8%" VALIGN="TOP">
<P ALIGN="CENTER">4</TD>
<TD WIDTH="61%" VALIGN="TOP">
<P><a href="30_avl-insert/avl_insert.pdf">AVL /(Height Balanced) Tree Insert&nbsp;</a> </TD>
<TD WIDTH="31%" VALIGN="TOP">
<P><A HREF="#avl_insert">Summary</A> &nbsp;</TD>
</tr>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="61%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="61%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="61%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="61%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
</TABLE>
</CENTER></P>

<P ALIGN="CENTER">&nbsp;</P>
<HR>

<div class=MsoNormal align=center style='text-align:center'>

&nbsp;</div>

<h2><a name=graphs>1. Undirected Graphs</a></h2>

<h4>Defn. <span style='mso-tab-count:1'>  </span>Undirected Graph</h4>

<p><span style='font-size:10.0pt'>We view a graph to mean a ‘simple’ graph,
i.e. the graph has at most one edge between vertices and there are no loops.<br>
A graph G = (V,E) consists of a set V of vertices and a set E of edges. Each
edge is an unordered pair, a 2-element set.<o:p></o:p></span></p>

<p><span style='font-size:10.0pt'>e.g.<span style='mso-tab-count:2'>                          </span>V
= {1,2,3,4,5,6}<span style='mso-tab-count:2'>                    </span>G = {
{1,2}, { 2,3}, {4,5} }<o:p></o:p></span></p>

<p><span style='font-size:10.0pt'>A graph may or may not be <u>connected</u>,
i.e. a graph may consist of more than one connected component.<o:p></o:p></span></p>

<h4><br>
Adjacency Matrix:</h4>

<p><span style='font-size:10.0pt'>We can implement a graph as a matrix, <br>
<span style='mso-tab-count:2'>                                </span>G :
ARRAY2[BOOLEAN], <br>
where we have 2 entries G(i,j) and G(j,i) are set to true for the edge {i,j}, <br>
i.e. G.item(i,j) </span><span style='font-size:10.0pt;font-family:Symbol'>Ù</span><span
style='font-size:10.0pt'> G.item(j,i) </span><span style='font-size:10.0pt;
font-family:Symbol'>º</span><span style='font-size:10.0pt'> there is an edge
from i to j.<o:p></o:p></span></p>

<h3><br>
Graph Traversal<span style='mso-tab-count:1'>   </span></h3>

<ul type=disc style="margin-bottom: 0cm">
 <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo8;tab-stops:list 36.0pt'><span style='font-size:
     10.0pt'>Depth First:<br>
     We start with a node and traverse along its descendants before going to
     next sibling. <o:p></o:p></span></li>
 <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo8;tab-stops:list 36.0pt'><span style='font-size:
     10.0pt'>Breadth First: <br>
     We traverse the graph ‘level by level’: i.e. the parent, the children, the
     grandchildren etc.<o:p></o:p></span></li>
</ul>

<p>
<a href="#contents" style="color: blue; text-decoration: underline; text-underline: single"><span style='font-size:10.0pt'>[back to contents</span></a><span
style='font-size:10.0pt'>]<o:p></o:p></span></p>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<h2>2. <a name=dag></a>Directed Acyclic Graphs (DAG) and Topological sort</h2>

<h4>Directed Graph, Digraph</h4>

<p><span style='font-size:10.0pt'>A Digraph is a graph is which each edge has a
direction. Directed edges are called <u>Arcs</u>.<br>
<span style='mso-tab-count:1'>                </span>D = (V,A) is a Digraph,<span
style='mso-tab-count:1'>        </span>where V = Set of Vertices<br>
<span style='mso-tab-count:5'>                                                                                </span>and
A = Set of Arcs, each arc is an ordered pair.<o:p></o:p></span></p>

<p><span style='font-size:10.0pt'>In effect, we have implemented (undirected)
Graphs as Digraphs as each edge {i,j} (unordered pair) is represented by two
arcs --directed edges, (i,j) and (j,i).<o:p></o:p></span></p>

<p><span style='font-size:10.0pt'>The In-degree of a vertex v is the number of
arcs leading <u>in</u>to v and the Out-degree of v is the number of arcs
leading <u>out</u> of v.<o:p></o:p></span></p>

<p><span style='font-size:10.0pt'>The <u>underlying</u> Graph of a digraph, D,
is the (undirected) graph where the arcs are viewed as (undirected) edges.<o:p></o:p></span></p>

<p><span style='font-size:10.0pt'>&nbsp;<o:p></o:p></span></p>

<h4>Directed Acyclic Graph, DAG</h4>

<p><span style='font-size:10.0pt'>A DAG is a Digraph with no circuits. The
underlying graph may have a cycle.<br>
<u>Note</u>: A graph is a Tree if it has no cycles.<o:p></o:p></span></p>

<p><span style='font-size:10.0pt'>A <u>Directed Tree</u> is a digraph in which
each vertex, except the root, has In-degree 1.<o:p></o:p></span></p>

<p><span style='font-size:10.0pt'>Vertices in a directed tree with Out-degree 0
are called <u>Leaves</u>.<o:p></o:p></span></p>

<p><span style='font-size:10.0pt'>&nbsp;<o:p></o:p></span></p>

<h4>Topological Sort</h4>

<p><span style='font-size:10.0pt'>A directed acylic graph (DAG) D gives rise to
a (strict) partial order on the vertices of D. <o:p></o:p></span></p>

<p><span style='font-size:10.0pt'><span style='mso-tab-count:1'>                </span>i
</span><span style='font-size:10.0pt;font-family:Symbol'>®</span><span
style='font-size:10.0pt'> j<span style='mso-tab-count:1'>        </span>&quot;i
can reach j&quot;<span style='mso-tab-count:1'>       </span>iff <span
style='mso-tab-count:1'>           </span>there is a path from i to j<o:p></o:p></span></p>

<p><span style='font-size:10.0pt'>The relation </span><span style='font-size:
10.0pt;font-family:Symbol'>®</span><span style='font-size:10.0pt'> is a
(strict) partial order on D as it is<o:p></o:p></span></p>

<ol start=1 type=1 style="margin-bottom: 0cm">
 <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l0 level1 lfo9;tab-stops:list 36.0pt'><span style='font-size:
     10.0pt'>Irreflexive: not( i </span><span style='font-size:10.0pt;
     font-family:Symbol'>®</span><span style='font-size:10.0pt'> i), there is
     no path from i to itself<o:p></o:p></span></li>
 <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l0 level1 lfo9;tab-stops:list 36.0pt'><span style='font-size:
     10.0pt'>Asymmetric: i </span><span style='font-size:10.0pt;font-family:
     Symbol'>®</span><span style='font-size:10.0pt'> j and j </span><span
     style='font-size:10.0pt;font-family:Symbol'>®</span><span
     style='font-size:10.0pt'> i is impossible<o:p></o:p></span></li>
 <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l0 level1 lfo9;tab-stops:list 36.0pt'><span style='font-size:
     10.0pt'>Transitive: if i </span><span style='font-size:10.0pt;font-family:
     Symbol'>®</span><span style='font-size:10.0pt'> j and j </span><span
     style='font-size:10.0pt;font-family:Symbol'>®</span><span
     style='font-size:10.0pt'> k then i </span><span style='font-size:10.0pt;
     font-family:Symbol'>®</span><span style='font-size:10.0pt'> k<o:p></o:p></span></li>
</ol>

<h4>Topological Order</h4>

<p><span style='font-size:10.0pt'>From a DAG, D, with PO (Partial Order) </span><span
style='font-size:10.0pt;font-family:Symbol'>®</span><span style='font-size:
10.0pt'> (&quot;reaches&quot;), we can generate a sequence of vertices S with
the following property;<br>
<span style='mso-tab-count:1'>                </span>if i </span><span
style='font-size:10.0pt;font-family:Symbol'>®</span><span style='font-size:
10.0pt'> j in D then i precedes j in the S.<br>
Such a sequence S is said to in Topological Order. For a given DAG there may be
more than one such order. <br>
In effect, the partial order of the DAG is embedded in the sequence.<o:p></o:p></span></p>

<p><span style='font-size:10.0pt'>[</span><a href="#contents" style="color: blue; text-decoration: underline; text-underline: single"><span
style='font-size:10.0pt'>back to contents</span></a><span style='font-size:
10.0pt'>]<o:p></o:p></span></p>

<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>

<h2><a name="hamilton">3. </a><st1:City><st1:place><span style='mso-bookmark:
  hamilton'>Hamilton</span></st1:place></st1:City><span style='mso-bookmark:
hamilton'> Circuit</span></h2>

<p><span style='font-size:10.0pt'>neighbour, then the path can be turned into a
</span><st1:City><st1:place><span style='font-size:10.0pt'>Hamilton</span></st1:place></st1:City><span
style='font-size:10.0pt'> cycle by joining the last vertex in the path to the
first vertex, i.e. a </span><st1:City><st1:place><span style='font-size:10.0pt'>Hamilton</span></st1:place></st1:City><span
style='font-size:10.0pt'> cycle is a path that returns to the start.<o:p></o:p></span></p>

<h3>&nbsp;Simple Properties of a <st1:City><st1:place>Hamilton</st1:place></st1:City>
Path/Cycle</h3>

<p><span style='font-size:10.0pt'>There are simple criteria that are useful in
analysing whether a graph has a </span><st1:City><st1:place><span
  style='font-size:10.0pt'>Hamilton</span></st1:place></st1:City><span
style='font-size:10.0pt'> path/circuit.<o:p></o:p></span></p>

<ul type=disc style="margin-bottom: 0cm">
 <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l5 level1 lfo10;tab-stops:list 36.0pt'><span style='font-size:
     10.0pt'>If G has a </span><st1:City><st1:place><span style='font-size:
       10.0pt'>Hamilton</span></st1:place></st1:City><span style='font-size:
     10.0pt'> circuit, then all vertices have degree </span><span
     style='font-size:10.0pt;font-family:Symbol'>³</span><span
     style='font-size:10.0pt'> 2. <o:p></o:p></span></li>
 <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l5 level1 lfo10;tab-stops:list 36.0pt'><span style='font-size:
     10.0pt'>If degree of v = 2 then both edges incident on v are in the
     circuit <o:p></o:p></span></li>
 <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l5 level1 lfo10;tab-stops:list 36.0pt'><span style='font-size:
     10.0pt'>If degree of v &gt; 2 and two edges incident on v are in a </span>
 <st1:City><st1:place><span
       style='font-size:10.0pt'>Hamilton</span></st1:place></st1:City><span
     style='font-size:10.0pt'> circuit, then the other edges incident on v are
     not in the </span><st1:City><st1:place><span style='font-size:10.0pt'>Hamilton</span></st1:place></st1:City><span
     style='font-size:10.0pt'> circuit.<o:p></o:p></span></li>
</ul>

<h3>The Knight’s Tour and <st1:City><st1:place>Hamilton</st1:place></st1:City>
Circuit.</h3>

<p><span style='font-size:10.0pt'>We can model the problem of the Knight’s
journey/tour by a graph (or digraph) . Each square on the board is a vertex and
each possible knight’s move is an edge. <o:p></o:p></span></p>

<ul type=disc style="margin-bottom: 0cm">
 <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l8 level1 lfo11;tab-stops:list 36.0pt'><span style='font-size:
     10.0pt'>There is no </span><st1:City><st1:place><span style='font-size:
       10.0pt'>Hamilton</span></st1:place></st1:City><span style='font-size:
     10.0pt'> path for a 4x4 board. <o:p></o:p></span></li>
 <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l8 level1 lfo11;tab-stops:list 36.0pt'><span style='font-size:
     10.0pt'>For odd N, there is no </span><st1:City><st1:place><span
       style='font-size:10.0pt'>Hamilton</span></st1:place></st1:City><span
     style='font-size:10.0pt'> cycle for an NxN board due to 'parity' of black
     and white squares<o:p></o:p></span></li>
</ul>

<h3>Theorem (<st1:State><st1:place>Ore</st1:place></st1:State>'s)</h3>

<p><span style='font-size:10.0pt'>Let G be an (undirected) graph of n vertices.
If for each pair of vertices, b and c, we have that the (degree of b) + (degree
of c) </span><span style='font-size:10.0pt;font-family:Symbol'>³</span><span
style='font-size:10.0pt'> n then G has a </span><st1:City><st1:place><span
  style='font-size:10.0pt'>Hamilton</span></st1:place></st1:City><span
style='font-size:10.0pt'> cycle.<o:p></o:p></span></p>

<p><b><span style='font-size:10.0pt'>Note</span></b><span style='font-size:
10.0pt'>: If a graph has a </span><st1:City><st1:place><span style='font-size:
  10.0pt'>Hamilton</span></st1:place></st1:City><span style='font-size:10.0pt'>
cycle, this does not mean that all pairs b, c satisfy (degree of b) + (degree
of c) </span><span style='font-size:10.0pt;font-family:Symbol'>³</span><span
style='font-size:10.0pt'> n.<o:p></o:p></span></p>

<p><span style='font-size:10.0pt'>[</span><a href="#contents" style="color: blue; text-decoration: underline; text-underline: single"><span
style='font-size:10.0pt'>back to contents</span></a><span style='font-size:
10.0pt'>]</span></p>

<hr size=2 width="100%" align=center>

<H2><A NAME="non_rec_inord"></A>1. Non-Recursive Inorder: via Stack and via Threaded Tree</H2>
<P>Two traditional approaches to elminating recursion are given:</P>

<UL>
<FONT FACE="Book Antiqua"><LI>Using an Explicit Stack <BR>
In Inorder traversal, the ‘first’ node is the left-most node. The program finds the first node, while stacking all the items on the path to the leftmost node. The leftmost node is also stacked but then immediately removed (and processed). We then move to the right node (if any) of this leftmost node and this node is now the root of a (sub)tree. We repeat the inorder traversal on this (sub)tree. The whole program halts when the stack is empty. </LI>
<LI>Using Threaded Trees <BR>
A Threaded Trees are used to implement a binary tree. This program has not the overhead of a stack but uses extra storage (a boolean-bit per node). A Threaded Tree takes advantage of the void links on the leaf nodes so as to have ‘threaded links’ to the inorder successor. An extra ‘flag’ attribute is needed per node to distinguish between a ‘thread’ and a ‘link’. This version "trades space for time". </LI></UL>

</FONT><P>[<A HREF="#contents">back to contents</A>]</P>
<P>&nbsp;<HR>
<p></p>
<H2><A NAME="morris"></A>2. Morris Inorder (Non-Recursive)</H2>
<P>We consider in more detail a solution to finding a non-recursive version for inorder using an algorithm by Joe Morris. This algorithm does not use an explicit stack. It is similar to the technique of using Threaded Trees but it does not use an extra 'boolean flag' to distinguish between 'thread links' and 'proper links'.</P>
<P>In more detail, if t is the root of a subtree then a link is formed from the rightmost of the left subtree of t, call it rm, to t itself. The inorder successor of rm is then t. After rm has being dealt with in the traversal, its right link is restored to void. During program execution, the binary tree is altered to contain cycles but these cycles are removed later.</P>
<P>In traversing the tree, the program has the overhead of setting new links but overall the program is runs in O(n) time.</P>
<P>[<A HREF="#contents">back to contents</A>]</P>
<HR>
<H2><A NAME="balanced_trees"></A>3. Balanced Trees (Perfectly Balanced .v. Height Balanced)</H2>
<P>In searching for an item in Binary Search Tree we want to reduce both <U>Average</U> and <U>Worst case</U> number of Comparisons. To achieve this we build a tree with minimal height. This can be achieved by filling all levels in the tree (except maybe the leaf level). </P>
<H4>Perfectly Balanced Trees.</H4>
<P>A perfectly balanced tree has minimal height. A tree t is perfectly balanced for each node the number of nodes in the left and right subtrees differ by at most one, i.e. for (sub)tree t.</P>
<H4>Height Balanced Tree -- AVL Tree</H4>
<P>A (Binary Search) Tree T is Height (AVL) Balanced if for any node k, the heights of the left and right subtrees of k differ by at most one.</P>
<P>i.e. | height(k.left) - height(k.right) | <FONT FACE="Symbol">£</FONT> 1</P>
<I><P>Note</I>: Height/Depth of Tree = Max level of all the nodes. (level of root = 1)</P>
<H4>Fibonacci Tree (Worse case AVL tree)</H4>
<P>An AVL balanced tree of height h with the minimum number of nodes is a Fibonacci tree. </P>
<H4>Minimum #Nodes</H4>
<P>The worst case AVL tree (Fibonacci tree) of height h can have a minimum of the Min(h) nodes where Min(h) &#9;= fib(h+2) - 1</P>
<H4>Conclusion</H4>
<P>For any AVL of height h we have</P>
<P>(Worst case -- fibonacci tree) Min(h) <FONT FACE="Symbol">£</FONT> #nodes <FONT FACE="Symbol">£</FONT> Max(h) = 2^h - 1 (Best case -- Complete tree)</P>
<P>Given n nodes, we can always build an AVL (Height Balanced) tree which at worst will be a Fibonacci tree or at best a Perfectly Balanced tree so that the height h will be<BR>
log (n+1) &lt; h &lt; 1.44 log(n+2) - 0.328</P>
<P>i.e. AVL trees require at most 45% more comparisons than Perfectly Balanced Trees</P>
<P>[<A HREF="#contents">back to contents</A>]</P>
<HR>
<p></p>
<H2><A NAME="avl_insert">4. Insertion into an AVL/(Height Balanced) Tree</A></H2>
<FONT FACE="Book Antiqua"><P>An AVL tree is a Height Balanced Search Tree. We use recursion to implement the insertion algorithm. In inserting an item in an AVL tree we may distort the balance, i.e. the heights of the left and right trees may differ by more than one. If tree is balanced after insertion then return this tree. If there is an imbalance then restore the balance using a series of 'rotations' of the roots of the appropriate subtrees.</P>
</FONT><H4>Efficiency<FONT SIZE=6> </FONT>of<FONT SIZE=6> </FONT>AVL trees</H4>
<P>If the tree contains n nodes, then the complexity of the operations Search, Add (Update) and Delete are proportional to the height of the tree.</P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=302>
<TR><TD WIDTH="50%" VALIGN="TOP">
<U><P>Operation</U></TD>
<TD WIDTH="50%" VALIGN="TOP">
<U><P>Time</U></TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<P>Search</TD>
<TD WIDTH="50%" VALIGN="TOP">
<P>O(log n)</TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<P>Add (Update/Insert)</TD>
<TD WIDTH="50%" VALIGN="TOP">
<P>O(log n)</TD>
</TR>
<TR><TD WIDTH="50%" VALIGN="TOP">
<P>Remove (Delete)</TD>
<TD WIDTH="50%" VALIGN="TOP">
<P>O(log n)</TD>
</TR>
</TABLE>

<P>&nbsp;</P>
<H4>Empirical Results.</H4>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=411>
<TR><TD WIDTH="55%" VALIGN="TOP">
<P>Average height</TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT FACE="Symbol"><P ALIGN="CENTER">»</FONT> </TD>
<TD WIDTH="36%" VALIGN="TOP">
<P>log n + 0.25</TD>
</TR>
<TR><TD WIDTH="55%" VALIGN="TOP">
<P>Prob. of Rebalance for Update:</TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="36%" VALIGN="TOP">
<P>0.5 (50%)</TD>
</TR>
<TR><TD WIDTH="55%" VALIGN="TOP">
<P>Prob. of Rebalance for Delete</TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="36%" VALIGN="TOP">
<P>0.2 (20%)</TD>
</TR>
</TABLE>

<P>&nbsp;</P>
<H4>Sorting</H4>
<P>&#9;Also, If the items are to be sorted or processed in sorted order, then time complexity is O(n) using Inorder Traversal.</P>
<P>[<A HREF="#contents">back to contents</A>]</P>
<P><HR>
<p></p>
<P>&nbsp;</P>
<P>&nbsp;<p>&nbsp;</p>

<A NAME="dag"></A></BODY>
</HTML>