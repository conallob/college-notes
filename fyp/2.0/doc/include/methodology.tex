% $Id$

\subsection{The Options}

There are many engineering methodologies widely used in software
development. At the time of writing, there are prodiminently two
catagories, pedictive and adaptive.


Predictive models attempt to control the engineering process and
catagorise each step into a particular order of phased development. 
Since there is often an unpredicable element in software development, 
these methodologies rely upon multiple iterations of their phases to 
process events, whether predictable or not. These phases include 
analysis of the requirements and specification of a system, modelling 
the system's architecture, coding, testing, documentation and 
maintainence. Examples of such methodologies include the Waterfall, 
Incremental and Rapid Prototype.


Adaptive, or agile lifecycles take a different arpproach to dealing 
with events, either unpredictable or otherwise. There are again named 
phases in agile development. However, there is no fixed iteration of 
phases, making them quite flexible, if somewhat disorganised. Many 
agile development methods are strongly iteritive processes, ensuring key 
issues are identified and dealt with quickly. They are also proven to
generate documentation rather well. Since agile methodologies are rather 
young, the best known examples are Extreme Programming (XP) and Lean 
Programming.


Finally, there are two lifecycles which are effectively hybrids of the
two catagories, the Win Win and Spiral lifecycles, which are both highly
iterative,predictive models. These models are best suited for large
scale products.

\subsection{The Road Taken}

The methodology employed during this project is not any of the
previously cited examples. As far as can be established, the development
process followed does not identify as known process. Based upon it's
flexability and modularity, it is definitely an agile lifecycle.

\subsubsection{The Process}

After providing initial requirements, research in to the feasability of
each requirement was performed. An initial list of specifications was
then derived.


After a list of specifications was created, milestones representing key
functionality stages were drawn up and deadline dates were given add
some to  the process. Coding development then commenced in tandem with 
research for other technology and documentation initiated. After each
milestone, the completed functionality is integrated in the result of
the completed milestones.


During the development process, in an effort to address unexpected 
events resulted and thus overdue deadlines, the outstanding milestones 
(and thus functionality) was reviewed and a single milestone was 
dropped from the critcal path. When a feature was dropped, the 
specifications were updated, resulting in documentation being regularly 
maintained and revised.


Full details of what milestones were dropped from the critical path
during the development of this project accompanied by a detailed
justification behind each decision is available in 
section~\ref{sec:progress} of appendix~\ref{chap:journal}.
