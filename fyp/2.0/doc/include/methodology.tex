% $Id$

\subsection{The Options}

There are many engineering methodologies widely used in software
development. At the time of writing, there are prodominently two
categories, predictive and adaptive.


Predictive models attempt to control the engineering process and
catogorise each step into a particular order of phased development. 
Since there is often an unpredictable element in software development, 
these methodologies rely upon multiple iterations of their phases to 
process events, whether predictable or not. These phases include 
analysis of the requirements and specification of a system, modeling 
the system's architecture, coding, testing, documentation and 
maintenance. Examples of such methodologies include the Waterfall, 
Incremental and Rapid Prototype.


Adaptive (or agile) life-cycles take a different approach to dealing 
with events, either unpredictable or otherwise. There are again named 
phases in agile development. However, there is no fixed iteration of 
phases, making them quite flexible, if somewhat disorganised. Many 
agile development methods are strongly iterative processes, ensuring key 
issues are identified and dealt with quickly. They are also proven to
generate documentation rather well. Since agile methodologies are rather 
young, the best known examples are Extreme Programming (XP) and Lean 
Programming.


Finally, there are two life-cycles which are effectively hybrids of the
two categories, the Win Win and Spiral life-cycles, which are both highly
iterative,predictive models. These models are best suited for large
scale products.

\subsection{The Road Taken}

The methodology employed during this project is not any of the
previously cited examples. The development process followed does not 
follow any known process. Based upon it's flexibility and modularity, 
it is definitely an agile life-cycle.

\subsubsection{The Process}

After providing initial requirements, research in to the feasibility of
each requirement was performed. An initial list of specifications was
then derived.


After a list of specifications was created, milestones representing key
functionality stages were drawn up and deadline dates were assigned to
the milestones. Coding development then commenced in tandem with 
research into other technologies and documentation was attended to. 
After each milestone, the completed functionality is integrated in the
core system.


During the development process, in an effort to address unexpected 
events and thus overdue deadlines, the outstanding milestones (and thus 
functionality) was reviewed and a single milestone was dropped from the 
critical path. When a feature was dropped, the specifications were 
updated, resulting in documentation being regularly maintained and 
revised.


Full details of what milestones were dropped from the critical path
during the development of this project accompanied by a detailed
justification behind each decision is available in 
section \ref{sec:fstat} of Chapter \ref{chap:conclusions}.
