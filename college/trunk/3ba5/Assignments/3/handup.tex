
\documentclass[a4paper,12pt]{article}

\setlength{\parindent}{0mm}
\setlength{\parskip}{7.5mm}

\usepackage{listings}

\begin{document}

\title{Course 3BA5: Computer Engineering \\ Assignment 3 \\ MPI} 

\author{Conall O'Brien \\ conallob@maths.tcd.ie \\ 01734351}

\maketitle

\section{}

\subsection{}

\lstinputlisting{functions1.c}

\subsection{}

\lstinputlisting{functions2.c}

\subsection{}

\lstinputlisting{matrix_mult1.c}

\subsection{}

\section{}

\subsection{}

In order to adapt my program to handle an $n$ by $n$ matrix, where $n$
is odd, I would form additional MPI communicators using 
\verb!MPI_Cart_create()!, which can be used as an MPI optimised data 
structures to represent data on a Cartesian plane.


In order to efficiently use the \verb!MPI_Cart! structure, I would not
rotate elements individually. I would simply readjust the origin of 
the data structre, allowing the data to readjust itself within the
structure's bounds, therefore simplifying the rotating algorithm to a
MPI library call which is optimised for distributed use and scalablilty.     



\subsection{}

In order to optimise the code to reduce execution time, I would restrict
I/O code to a minimum, since I/O request are traditionally the slowest
calls in executing programs.


To optimise the code further, I would try to reduce the memory usage of
the data structures being used to store matrice data, by storing the
data in single dimension vectors with additional terminators at the
start and end, such as ones created using
\verb!MPI_Type_vector!. Such a vector setup can easily be traversed and
referenced as if it is a multidimensional array, simply by knowing the
intended length and breath values and navigating using offsets.

\end{document}
